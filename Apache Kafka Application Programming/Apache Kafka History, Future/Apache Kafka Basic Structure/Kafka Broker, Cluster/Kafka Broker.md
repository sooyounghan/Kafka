-----
### 브로커의 역할
-----
1. 컨트롤러
   - 클러스터의 다수 브로커 중 한 대가 컨트롤러 역할을 함
   - 컨트롤러는 다른 브로커들의 상태를 체크하고, 브로커가 클러스터에서 빠지는 경우 해당 브로커에 존재하는 리더 파티션을 재분배
   - 카프카는 지속적으로 데이터를 처리해야 하므로 브로커의 상태가 비정상이라면, 빠르게 클러스터에서 빼내는 것이 중요
   - 만약, 컨트롤러 역할을 하는 브로커에 장애가 생기면, 다른 브로커가 컨트롤러 역할을 함

2. 데이터 삭제
   - 카프카는 다른 메세징 플랫폼과 다르게 컨슈머가 데이터를 가져가더라도 토픽의 데이터는 삭제되지 않음
   - 또한, 컨슈머나 프로듀서가 데이터 삭제를 요청할 수도 없음
   - 오직 브로커만이 데이터를 삭제할 수 있음
   - 데이터 삭제는 파일 단위로 이루어지는데 이 단위를 '로그 세그먼트(Log Segment)'라고 부름 (일정 시간 / 용량 또는 특수한 상황에서 Compact이라는 옵션을 주게 되면 가장 최신의 메세지 키가 있는 레코드를 제외하고 나머지 키가 있는 레코드들을 모두 삭제)
   - 이 세그먼트에는 다수의 데이터가 들어있으므로 일반적인 데이터베이스처럼 특정 데이터를 선별해서 삭제할 수 없음

3. 컨슈머 오프셋 저장
   - 컨슈머 그룹은 토픽이 특정 파티션으로부터 데이터를 가져가서 처리하고 이 파티션이 어느 레코드까지 가져갔는지 확인하기 위해 오프셋을 커밋
   - 커밋한 오프셋은 __consumer_offsets 토픽에 저장 (이 토픽은 카프카를 생성하고, 컨슈머를 생성하여 컨슈머 그룹을 운영할 때 커밋 이후에 자동 생성 : Internal Topic이라 부름)
   - 여기에 저장된 오프셋을 토대로 컨슈머 그룹은 다음 레코드를 가져가서 처리

4. 그룹 코디네이터
   - 코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할을 함 (기본적으록 각각의 파티션은 컨슈머와 1:1 매핑이 되고, 특정 파티션에 문제가 발생하면, 문제가 발생한 컨슈머는 삭제하고, 컨슈머 한 대가 여러 파티션을 가져와서 데이터를 지속적 처리)
   - 컨슈머가 컨슈머 그룹에서 빠지면 매칭되지 않은 파티션을 정상 동작하는 컨슈머로 할당하여 끊임없이 데이터가 처리되도록 도오줌
   - 이렇게 파티션을 컨슈머로 재할당하는 과정을 '리밸런스(Rebalance)'라고 부름
     + 리밸런스 과정을 통해 문제가 있는 컨슈머를 삭제하고 나머지 컨슈머가 데이터를 처리
     + 이 과정을 통해 문제가 발생하더라도 지속적으로 데이터를 처리


